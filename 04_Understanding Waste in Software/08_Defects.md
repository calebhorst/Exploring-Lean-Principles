## Defects
```
We round out the wastes with the most obvious form, defects. This form of waste maps most directly back to manufacturing, a car that doesn't run, a part that crumbles in your hand. And look down the rest of the list, every one of these forms of waste can accrue to defects. The pursuit of the elimination of defects is like the pursuit of speed. It is a clarifying and purifying force in your processes. That is to say, if you aim it speed in the absent of defects, you'll get a host of other quality measures along with them. There are large companies that pursue full, continuous deployment, whereby a check‑in triggers a build, which triggers automated testing, which generates documentation, and triggers a deployment to production. This can seem insane to people who haven't done it. The knee jerk response to this is, How can you deploy without having tested it? To ask this question is to misunderstand nearly every aspect of testing, what it's for, when it happens, and who does it. Remember from the last section that we don't inspect to find defects, we inspect to prevent defects. Let's say that in implementing continuous deployment we change our bill to require that all new code has 100% test coverage. There's no branch of the logic that isn't being exercised before it goes to production. At the same time, the build has tools which scan new code for recognized security problems; both in the form of static analysis tools which analyze the actual code, and in dynamic analysis tools, which actually execute it. Okay, you might say, but I can write a lousy test that satisfies test coverage, any competent developer can. But if you're working in pair programming, the other developers shouldn't let you do that. But, let's say that they do. You're both slackers that are trying to get out the door before five o'clock, but then you commit your changes to your branch and execute a pull request. The request to merge your changes into the branch triggers a build, which verifies that your code at least compiles and executes your test, though we've already stipulated that it's a lousy test. Then the request requires approval from three independent developers. In large organizations, this may be their only job. They're going to look at your code and possibly even check it out and execute it before they approve it. But let's say that all three of these guys are just about to retire, and they approve your garbage unit tests and your unit code. Now the merged branch is tested using all of the automated tests from before: unit tests, integration tests, tests run against actual scrubbed databases pulled from production, as well as test data stores designed to exercise every corner of the code. Failure is possible in this scenario, but it relies on a chain of irresponsibility all the way up. It's difficult to imagine. On January 27th, 1967 NASA conducted a plugs‑out test of the Apollo capsule, meaning that the ordinary umbilicals that would supply the capsule with are were removed. During the test, the capsule was over‑pressurized with pure oxygen to reflect the internal pressure that the capsule would experience when the craft was in space. A spark from a tool on the floor ignited a piece of Velcro, and the fire quickly consumed the cabin, killing astronauts Roger Chaffee, Ed White, and Gus Grissom. Designated AS‑204, this test would retroactively be named Apollo 1. During his testimony to Congress about the accident, astronaut Frank Borman explained that the accident had occurred due to a failure of imagination. All of the problems they anticipated occurred in space. It hadn't occurred to them that a disaster could happen during the testing on the ground. NASA would need to become much better at imagining disaster in the future. When you ask yourself if there are defects in your code, there are two answers. Yes, and I can't imagine one. There's no no. And the logical follow up question to ask yourself is, Are you especially good imagining failure in your code? The answer that any experienced developer should deliver to this question is again, no. This no should be the beginning of building in people, processes, and automation that is better at imagining than you.
```

## Notes
- Defects in software development are the most obvious form of waste, akin to manufacturing defects that result in non-functional products.
- Pursuing the elimination of defects is a clarifying and purifying force in software development processes, leading to improved quality.
- Full, continuous deployment practices involve automating the build, testing, documentation generation, and deployment processes, ensuring comprehensive test coverage and security checks.
- Automated testing, code reviews, and approvals by multiple developers help prevent defects from entering the production environment.
- The importance of imagining potential failures and disasters in software development is emphasized, as even experienced developers may struggle to foresee all possible defects.
- Building processes and automation to help anticipate and prevent defects is crucial for improving software quality and reliability.